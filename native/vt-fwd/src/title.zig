const std = @import("std");

const dot_separator = " \u{00b7} ";

pub fn abbreviatePath(allocator: std.mem.Allocator, full_path: []const u8, home: []const u8) ![]u8 {
    var path_buf = try allocator.dupe(u8, full_path);

    if (home.len > 0 and std.mem.startsWith(u8, path_buf, home)) {
        const suffix = path_buf[home.len..];
        allocator.free(path_buf);
        path_buf = try std.fmt.allocPrint(allocator, "~{s}", .{suffix});
    }

    path_buf = try replaceOwned(allocator, path_buf, "/Development/", "/Dev/");
    path_buf = try replaceOwned(allocator, path_buf, "/Documents/", "/Docs/");
    path_buf = try replaceOwned(allocator, path_buf, "/Applications/", "/Apps/");

    var parts = std.ArrayList([]const u8).empty;
    defer parts.deinit(allocator);
    var it = std.mem.splitScalar(u8, path_buf, '/');
    while (it.next()) |part| {
        if (part.len == 0) continue;
        try parts.append(allocator, part);
    }

    if (parts.items.len > 3) {
        const tail = parts.items[parts.items.len - 2 ..];
        allocator.free(path_buf);
        return std.fmt.allocPrint(allocator, ".../{s}/{s}", .{ tail[0], tail[1] });
    }

    return path_buf;
}

fn replaceOwned(
    allocator: std.mem.Allocator,
    input: []u8,
    needle: []const u8,
    replacement: []const u8,
) ![]u8 {
    const replaced = try std.mem.replaceOwned(u8, allocator, input, needle, replacement);
    allocator.free(input);
    return replaced;
}

pub fn generateSessionName(
    allocator: std.mem.Allocator,
    command: []const []const u8,
    working_dir: []const u8,
    home: []const u8,
) ![]u8 {
    const cmd = if (command.len > 0) command[0] else "shell";
    const cmd_name = std.fs.path.basename(cmd);
    const abbrev = try abbreviatePath(allocator, working_dir, home);
    defer allocator.free(abbrev);
    if (abbrev.len == 0) {
        return allocator.dupe(u8, cmd_name);
    }
    return std.fmt.allocPrint(allocator, "{s} ({s})", .{ cmd_name, abbrev });
}

pub fn generateTitleSequence(
    allocator: std.mem.Allocator,
    cwd: []const u8,
    command: []const []const u8,
    session_name_opt: ?[]const u8,
    home: []const u8,
) ![]u8 {
    const cmd = if (command.len > 0) command[0] else "shell";
    const cmd_name = std.fs.path.basename(cmd);
    const display_path = if (home.len > 0 and std.mem.startsWith(u8, cwd, home))
        try std.fmt.allocPrint(allocator, "~{s}", .{cwd[home.len..]})
    else
        try allocator.dupe(u8, cwd);
    defer allocator.free(display_path);

    if (session_name_opt) |raw_name| {
        const trimmed = std.mem.trim(u8, raw_name, " \t\r\n");
        if (trimmed.len > 0 and !isAutoGeneratedName(trimmed, cmd_name)) {
            return std.fmt.allocPrint(allocator, "\x1b]2;{s}\x07", .{trimmed});
        }
    }

    var parts = std.ArrayList([]const u8).empty;
    defer parts.deinit(allocator);
    try parts.append(allocator, display_path);
    try parts.append(allocator, cmd_name);

    if (session_name_opt) |raw_name| {
        const trimmed = std.mem.trim(u8, raw_name, " \t\r\n");
        if (trimmed.len > 0 and !isRedundantName(trimmed, cmd_name)) {
            try parts.append(allocator, trimmed);
        }
    }

    const joined = try joinParts(allocator, parts.items);
    defer allocator.free(joined);
    return std.fmt.allocPrint(allocator, "\x1b]2;{s}\x07", .{joined});
}

fn joinParts(allocator: std.mem.Allocator, parts: []const []const u8) ![]u8 {
    var total_len: usize = 0;
    for (parts) |part| total_len += part.len;
    if (parts.len > 1) total_len += dot_separator.len * (parts.len - 1);

    var buf = try allocator.alloc(u8, total_len);
    var cursor: usize = 0;
    for (parts, 0..) |part, idx| {
        if (idx > 0) {
            std.mem.copyForwards(u8, buf[cursor..][0..dot_separator.len], dot_separator);
            cursor += dot_separator.len;
        }
        std.mem.copyForwards(u8, buf[cursor..][0..part.len], part);
        cursor += part.len;
    }
    return buf;
}

fn isAutoGeneratedName(name: []const u8, cmd_name: []const u8) bool {
    if (std.mem.eql(u8, name, cmd_name)) return true;
    if (name.len == cmd_name.len * 2 + dot_separator.len) {
        if (std.mem.startsWith(u8, name, cmd_name) and std.mem.endsWith(u8, name, cmd_name)) {
            const mid = name[cmd_name.len..name.len - cmd_name.len];
            if (std.mem.eql(u8, mid, dot_separator)) return true;
        }
    }
    if (std.mem.startsWith(u8, name, cmd_name) and name.len > cmd_name.len + 2) {
        if (name[cmd_name.len] == ' ' and name[cmd_name.len + 1] == '(' and name[name.len - 1] == ')') {
            return true;
        }
    }
    return false;
}

fn isRedundantName(name: []const u8, cmd_name: []const u8) bool {
    if (std.mem.eql(u8, name, cmd_name)) return true;
    if (name.len == cmd_name.len * 2 + dot_separator.len) {
        if (std.mem.startsWith(u8, name, cmd_name) and std.mem.endsWith(u8, name, cmd_name)) {
            const mid = name[cmd_name.len..name.len - cmd_name.len];
            if (std.mem.eql(u8, mid, dot_separator)) return true;
        }
    }
    if (std.mem.startsWith(u8, name, cmd_name) and name.len > cmd_name.len + 2) {
        if (name[cmd_name.len] == ' ' and name[cmd_name.len + 1] == '(' and name[name.len - 1] == ')') {
            return true;
        }
    }
    return false;
}

pub fn sanitizeTitle(allocator: std.mem.Allocator, title: []const u8) ![]u8 {
    var list = std.ArrayList(u8).empty;
    errdefer list.deinit(allocator);

    const view = std.unicode.Utf8View.init(title) catch {
        for (title) |b| {
            if (b >= 32 and b != 127 and (b < 128 or b > 159)) {
                try list.append(allocator, b);
            }
            if (list.items.len >= 256) break;
        }
        return list.toOwnedSlice(allocator);
    };

    var it = view.iterator();
    var count: usize = 0;
    while (it.nextCodepointSlice()) |slice| {
        const cp = std.unicode.utf8Decode(slice) catch continue;
        if (cp >= 32 and cp != 127 and (cp < 128 or cp > 159)) {
            try list.appendSlice(allocator, slice);
            count += 1;
            if (count >= 256) break;
        }
    }

    return list.toOwnedSlice(allocator);
}
